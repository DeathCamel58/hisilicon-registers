`ifndef SYS_CTRL_RDL
`define SYS_CTRL_RDL

regfile eSYS_CTRL {
    name = "System Controller Registers";

    /* Useful enums to keep from having to keep copying them */
    enum SYSCTL_zero_enable_enum {
        ENABLE  = 0x0 { desc = "Enable"; };
        DISABLE = 0x1 { desc = "Disable"; };
    };

    enum SYSCTL_one_enable_enum {
        ENABLE  = 0x0 { desc = "Enable"; };
        DISABLE = 0x1 { desc = "Disable"; };
    };

    /* Fields */

    reg {
        name = "System control register";
        desc = "It is used to specify the operations to be performed by the system.";

`ifdef SYS_CTRL_timeren7ov_31_FIELD
        enum SC_CTRL_timeren7ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren7sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren7ov";
            desc = "Timer7 count clock selection.";
            encode = SC_CTRL_timeren7ov_enum;
        } timeren7ov[31:31];
`endif
        enum SC_CTRL_timerenNsel_enum {
            MHz3 = 0x0 { desc = "Use 3MHz clock for counting"; };
            // RESERVED = 0x1 { desc = "Reserved"; };
        };

`ifdef SYS_CTRL_timeren7sel_30_FIELD
        field {
            name = "timeren7sel";
            desc = " Timer7 counting clock frequency selection. Must be configured as 0. ";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren7sel[30:30];
`endif

`ifdef SYS_CTRL_timeren6ov_29_FIELD
        enum SC_CTRL_timeren6ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren6sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren6ov";
            desc = "Timer6 count clock selection.";
            encode = SC_CTRL_timeren6ov_enum;
        } timeren6ov[29:29];
`endif

`ifdef SYS_CTRL_timeren6sel_28_FIELD
        field {
            name = "timeren6sel";
            desc = "Timer6 counting clock frequency selection. Must be configured as 0.";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren6sel[28:28];
`endif

`ifdef SYS_CTRL_timeren5ov_27_FIELD
        enum SC_CTRL_timeren5ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren5sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren5ov";
            desc = " Timer5 count clock selection.";
            encode = SC_CTRL_timeren5ov_enum;
        } timeren5ov[27:27];
`endif

`ifdef SYS_CTRL_timeren5sel_26_FIELD
        enum SC_CTRL_timeren5sel_enum {
            MHz3 = 0x0 { desc = "Use 3MHz clock for counting"; };
            // RESERVED = 0x1 { desc = "Reserved"; };
        };

        field {
            name = "timeren5sel";
            desc = "Timer5 counting clock frequency selection. Must be configured as 0.";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren5sel[26:26];
`endif

`ifdef SYS_CTRL_timeren4ov_25_FIELD
        enum SC_CTRL_timeren4ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren4sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren4ov";
            desc = "Timer4 count clock selection.";
            encode = SC_CTRL_timeren4ov_enum;
        } timeren4ov[25:25];
`endif

`ifdef SYS_CTRL_timeren4sel_24_FIELD
        field {
            name = "timeren4sel";
            desc = "Timer4 counting clock frequency selection. Must be configured as 0.";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren4sel[24:24];
`endif

`ifdef SYS_CTRL_wdogenov_23_FIELD
        enum SC_CTRL_wdogenov_enum {
            MHz3    = 0x0 { desc = "WDG uses 3MHz clock for counting."; };
            BUS_CLK = 0x1 { desc = "WDG uses the bus clock for counting."; };
        };

        field {
            name = "wdogenov";
            desc = "WDG count clock selection.";
            encode = SC_CTRL_wdogenov_enum;
        } wdogenov[23:23];
`endif

`ifdef SYS_CTRL_timeren7ov_23_FIELD
        enum SC_CTRL_timeren7ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren7sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren7ov";
            desc = "Timer7 count clock selection.";
            encode = SC_CTRL_timeren7ov_enum;
        } timeren7ov[23:23];
`endif

`ifdef SYS_CTRL_timeren3ov_22_FIELD
        enum SC_CTRL_timeren3ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren3sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren3ov";
            desc = "Timer3 count clock selection.";
            encode = SC_CTRL_timeren3ov_enum;
        } timeren3ov[22:22];
`endif

`ifdef SYS_CTRL_timeren6ov_22_FIELD
        enum SC_CTRL_timeren6ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren6sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren6ov";
            desc = "Timer6 count clock selection.";
            encode = SC_CTRL_timeren6ov_enum;
        } timeren6ov[22:22];
`endif

`ifdef SYS_CTRL_timeren3sel_21_FIELD
        field {
            name = "timeren3sel";
            desc = "Timer3 counting clock frequency selection. Must be configured as 0.";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren3sel[21:21];
`endif

`ifdef SYS_CTRL_timeren5ov_21_FIELD
        enum SC_CTRL_timeren5ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren5sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren5ov";
            desc = "Timer5 count clock selection.";
            encode = SC_CTRL_timeren6ov_enum;
        } timeren5ov[21:21];
`endif

`ifdef SYS_CTRL_timeren2ov_20_FIELD
        enum SC_CTRL_timeren2ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren2sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren2ov";
            desc = "Timer2 count clock selection.";
            encode = SC_CTRL_timeren2ov_enum;
        } timeren2ov[20:20];
`endif

`ifdef SYS_CTRL_timeren4ov_20_FIELD
        enum SC_CTRL_timeren4ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren4sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren4ov";
            desc = "Timer4 count clock selection.";
            encode = SC_CTRL_timeren4ov_enum;
        } timeren4ov[20:20];
`endif

`ifdef SYS_CTRL_timeren2sel_19_FIELD
        field {
            name = "timeren2sel";
            desc = "Timer2 counting clock frequency selection. Must be configured as 0.";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren2sel[19:19];
`endif

`ifdef SYS_CTRL_timeren3ov_19_FIELD
        enum SC_CTRL_timeren3ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren3sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren3ov";
            desc = "Timer3 count clock selection.";
            encode = SC_CTRL_timeren3ov_enum;
        } timeren3ov[19:19];
`endif

`ifdef SYS_CTRL_timeren1ov_18_FIELD
        enum SC_CTRL_timeren1ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren1sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren1ov";
            desc = "Timer1 count clock selection.";
            encode = SC_CTRL_timeren1ov_enum;
        } timeren1ov[18:18];
`endif

`ifdef SYS_CTRL_timeren2ov_18_FIELD
        enum SC_CTRL_timeren2ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren2sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren2ov";
            desc = "Timer2 count clock selection.";
            encode = SC_CTRL_timeren2ov_enum;
        } timeren2ov[18:18];
`endif

`ifdef SYS_CTRL_timeren1sel_17_FIELD
        field {
            name = "timeren1sel";
            desc = "Timer1 counting clock frequency selection. Must be configured as 0.";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren1sel[17:17];
`endif

`ifdef SYS_CTRL_timeren1ov_17_FIELD
        enum SC_CTRL_timeren1ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren1sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren1ov";
            desc = "Timer1 count clock selection.";
            encode = SC_CTRL_timeren1ov_enum;
        } timeren1ov[17:17];
`endif

`ifdef SYS_CTRL_timeren0ov_16_FIELD
        enum SC_CTRL_timeren0ov_enum {
            REF_CLK = 0x0 { desc = "The enable signal is obtained by using the reference clock, and the selection of the reference clock is specified by [timeren0sel]"; };
            BUS_CLK = 0x1 { desc = "Counting by the bus clock."; };
        };

        field {
            name = "timeren0ov";
            desc = "Timer0 count clock selection.";
            encode = SC_CTRL_timeren0ov_enum;
        } timeren0ov[16:16];
`endif

`ifdef SYS_CTRL_timeren0sel_15_FIELD
        field {
            name = "timeren0sel";
            desc = "Timer0 counting clock frequency selection. Must be configured as 0.";
            encode = SC_CTRL_timerenNsel_enum;
        } timeren0sel[15:15];
`endif

        enum SC_CTRL_remapstat_enum {
            NO_REMAP = 0x0 { desc = "No address remapping."; };
            REMAP    = 0x1 { desc = "Perform address remapping. bootrom or SFC CS1 is remapped to address 0."; };
        };

        field {
            name = "remapstat";
            desc = "Status of address remapping.";
            encode = SC_CTRL_remapstat_enum;
            sw=r;
        } remapstat[9:9];

        enum SC_CTRL_remapclear_enum {
            NO_REMAP = 0x0 { desc = "Keep Remap status."; };
            REMAP    = 0x1 { desc = "Clear Remap."; };
        };

        field {
            name = "remapclear";
            desc = "
                Address remapping clears the selection.
                For the address mapping relationship before and after Clear Remap, see Address Allocation.
            ";
            encode = SC_CTRL_remapclear_enum;
        } remapclear[8:8];

`ifdef SYS_CTRL_modestatus_FIELD
        enum SC_CTRL_modestatus_enum {
            // Reserved       = 0x0 { desc = "Reserved"; };
            DOZE            = 0x1 { desc = "DOZE"; };
            SLOW            = 0x2 { desc = "SLOW"; };
            XTAL_CTL        = 0x3 { desc = "XTAL CTL"; };
            NORMAL          = 0x4 { desc = "NORMAL"; };
            // Reserved       = 0x5 { desc = "Reserved"; };
            PLL_CTL         = 0x6 { desc = "PLL CTL"; };
            // Reserved       = 0x7 { desc = "Reserved"; };
            // Reserved       = 0x8 { desc = "Reserved"; };
            SW_from_XTAL    = 0x9 { desc = "SW from XTAL"; };
            SW_from_PLL     = 0xA { desc = "SW from PLL"; };
            SW_to_XTAL      = 0xB { desc = "SW to XTAL"; };
            // Reserved       = 0xC { desc = "Reserved"; };
            // Reserved       = 0xD { desc = "Reserved"; };
            SW_to_PLL       = 0xE { desc = "SW to PLL"; };
            // Reserved       = 0xF { desc = "Reserved"; };
        };

        field {
            name = "modestatus";
            desc = "
                Address remapping clears the selection.
                For the address mapping relationship before and after Clear Remap, see Address Allocation.
            ";
            encode = SC_CTRL_remapclear_enum;
        } modestatus[6:3];
`endif

`ifdef SYS_CTRL_modectrl_FIELD
        enum SC_CTRL_modectrl_enum {
            // Reserved   = 0x0 { desc = "Reserved"; };
            DOZE        = 0x1 { desc = "DOZE"; };
            SLOW        = 0x2 { desc = "SLOW"; };
            NORMAL      = 0x4 { desc = "NORMAL"; };
        };

        field {
            name = "modectrl";
            desc = "Mode control bit. Defines the operating modes that the system controller is required to enter.";
            encode = SC_CTRL_modectrl_enum;
        } modectrl[2:0];
`endif

    } CTRL @ 0x0000;

    reg {
        name = "System soft reset register";
        desc = "
            When a value is written to this register, the system controller
            sends a system soft reset request to the reset module.
            Then the reset module resets the system.

            !!! Caution
                Write protection for this register can be enabled by configuring
                SC_LOCKEN. This register can be written only when write protection
                is disabled.
        ";

        field {
            name = "softresreq";
            desc = "Any write operation to this register will cause a soft reset of the system.";
            sw=w;
        } softresreq[31:0];

    } SYSRES @ 0x0004;

`ifdef SYS_CTRL_IMCTRL_REG
    reg {
        name = "Interrupt mode control register";
        desc = "The interrupt mode control register. Used to control the system mode when an interrupt occurs.";

        enum itmdctrl_inmdtype_enum {
            FIQ_ONLY    = 0x0 { desc = "Only FIQ interrupt can make the system enter interrupt mode."; };
            FIQ_AND_IRQ = 0x1 { desc = "Both FIQ interrupt and IRQ interrupt can make the system enter interrupt mode."; };
        };

        field {
            name = "inmdtype";
            desc = "The type of interrupt that triggers the system to enter interrupt mode.";
            encode = itmdctrl_inmdtype_enum;
        } inmdtype[7:7];

        enum itmdctrl_modectrl_enum {
            SLEEP   = 0x0 { desc = "SLEEP"; };
            DOZE    = 0x1 { desc = "DOZE"; };
            SLOW    = 0x2 { desc = "SLOW"; };
            NORMAL  = 0x3 { desc = "NORMAL"; };
        };

        field {
            name = "itmdctrl";
            desc = "The lowest working mode of the system in interrupt mode, the value of this register is ORed with the value of SC_CTRL[modectrl] as the working mode of the system after the interrupt occurs.";
            encode = itmdctrl_modectrl_enum;
        } modectrl[3:1];

        enum itmdctrl_itm_enum {
            FORBIDDEN = 0x0 { desc = "Forbidden."; };
            ENABLE    = 0x1 { desc = "Enable (enter interrupt mode when interrupt occurs)."; };
        };

        field {
            name = "itm";
            desc = "Interrupt mode enable.";
            encode = itmdctrl_itm_enum;
        } itm[0:0];

    } IMCTRL @ 0x0008;
`endif

`ifdef SYS_CTRL_IMSTAT_REG
    reg {
        name = "Interrupt mode status register";
        desc = "
            The interrupt mode status register. It is used to monitor whether the system is in the interrupt mode, and the system can also be forced to enter the interrupt mode by configuring this register.

            !!! Caution
                The interrupt mode must be cleared manually when the interrupt service routine is finished.
        ";

        field {
            name = "itmdstat";
            desc = "
                Interrupt mode status. Can be used for software control to directly enter interrupt mode.

                When reading this register:
                0: Not currently in interrupt mode.
                1: Currently in interrupt mode.

                When writing this register:
                0: Software does not control to enter interrupt mode.
                1: Software controls to enter interrupt mode.
            ";
        } itmdstat[0:0];

    } IMSTAT @ 0x000C;
`endif

`ifdef SYS_CTRL_XTALCTRL_REG
    reg {
        name = "Crystal oscillator control register";
        desc = "The crystal oscillator control register. It is used to control the stable waiting time of the initialization clock module, that is, the waiting time for jumping from the XTAL CTL intermediate state to the SW to XTAL intermediate state.";

        field {
            name = "xtaltime";
            desc = "
                Crystal switching wait time.
                The value of this field is used to specify the waiting time for switching from XTAL CTL state to SW to XTAL state when the system mode is switched. The number of waiting cycles can be calculated (T46.8K is a 46.8KHz low-frequency clock cycle): (65536 – xtaltime)xT46.8K.
            ";
        } xtaltime[18:3];

    } XTALCTRL @ 0x0010;
`endif

`ifdef SYS_CTRL_PLLCTRL_REG
    reg {
        name = "PLL control register";
        desc = "
            The PLL control register. It is used to control the enable control of the on-chip ARM phase-locked loop (ARMPLL), which is enabled by software control or by system mode switching. In addition, this register is also used to set the ARMPLL PLL stabilization wait time.

            !!! Caution
                This register can be write-protected by the register SC_LOCKEN, and the write operation to this register is valid only when the write protection is disabled.

            When it is in the 'Enable ARMPLL phase-locked loop controlled by system mode switching' (controlled by SC_PLLCTRL[pllover]), ARMPLL is automatically turned off when the system is in non-NORMAL mode. The clock frequency of ARMPLL is controlled by CRG registers PERI_CRG0 and PERI_CRG1. The system requires the PLL to wait for 0.5ms to output a stable clock when changing the frequency configuration. Therefore, the plltime configuration of this register must meet this requirement.
        ";

        field {
            name = "plltime";
            desc = "
                ARMPLL PLL stabilization wait time. This period of time is used to wait for the PLL to start and the PLL output to reach a stable state, which is to specify the waiting time for switching from the PLL CTL state to the SW to PLL state when switching from the system mode. The timeout value is calculated by the following formula (TXIN is the clock cycle of the external crystal oscillator): (33554432 - plltime)xTXIN.
            ";
        } plltime[27:3];

        enum SC_PLLCTRL_pllover_enum {
            ENABLE = 0x0 { desc = "Enable the ARMPLL phase-locked loop by switching the system mode."; };
            // RESERVED = 0x1 { desc = "Reserved."; };
        };

        field {
            name = "pllover";
            desc = "Allows the ARLPLL PLL to be enabled directly under software control, rather than being controlled by system mode state changes. Must be configured as 0.";
            encode = SC_PLLCTRL_pllover_enum;
        } pllover[0:0];

    } PLLCTRL @ 0x0014;
`endif

`ifdef SYS_CTRL_PLLFCTRL_REG
    reg {
        name = "PLL Frequency Control Register";
        desc = "
            Used to control the frequency of ARMPLL and enable the bypass function. When ARMPLL needs to be bypassed, set the SC_PLLFCTRL[armpll_bypass] bit to 1. At this time, ARMPLL outputs and external crystal oscillator clock.

            The phase locked loop output clock frequency is calculated by this formula: `Fpll = Fxin * M/(N*2^OD)`

            Where:

                * `M` >= 2
                * `N` >= 2
                * 1MHz <= `Fxin/N` <= 25MHz
                * 200MHz <= `Fpll*2^OD` <= 1GHz

            * `Fxin` is the clock frequency of the external crystal oscillator
            * `Fpll` is the PLL output clock
            * `M`, `N`, and `OD` are configured with the corresponding bits in the register
        ";

        enum SC_PLLCTRL_armpll_bypass_enum {
            NO_BYPASS = 0x0 { desc = "Don't bypass"; };
            BYPASS    = 0x1 { desc = "Bypass"; };
        };

        field {
            name = "armpll_bypass";
            desc = "ARMPLL clock divider bypass control.";
            encode = SC_PLLCTRL_armpll_bypass_enum;
        } armpll_bypass[14:14];

        field {
            name = "armpll_od";
            desc = "ARM clock frequency division control, OD, output frequency division coefficient";
        } armpll_od[13:12];

        field {
            name = "armpll_m";
            desc = "ARM clock frequency division control, M, multiplication factor";
        } armpll_m[11:4];

        field {
            name = "armpll_n";
            desc = "ARM clock frequency division control, N, frequency division coefficient";
        } armpll_n[3:0];

    } PLLFCTRL @ 0x0018;
`endif

`ifdef SYS_CTRL_PERIPHCTRL0_REG
    reg {
        name = "Peripheral control register 0";
        desc = "
            The peripheral control register 0.

            !!! Caution
                This register can be write-protected by the register SC_LOCKEN, and the write operation to this register is valid only when the write protection is disabled.
        ";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL0 @ 0x001C;
`endif

`ifdef SYS_CTRL_SOFT_INT_REG
    reg {
        name = "Software Interrupt Register";

        enum SOFT_INT_software_int_enum {
            NO_INTERRUPT = 0x0 { desc = "No interrupt is generated."; };
            INTERRUPT    = 0x1 { desc = "An interrupt is generated."; };
        };

        field {
            name = "software_int";
            desc = "Software Interrupt";
            encode = SOFT_INT_software_int_enum;
        } software_int[0:0];

    } SOFT_INT @ 0x001C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL1_REG
    reg {
        name = "Peripheral control register 1";
        desc = "Soft interrupt register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL1 @ 0x0020;
`endif

`ifdef SYS_CTRL_SOLFTYPE_REG
    reg {
        name = "Software Interrupt Vector Register";
        desc = "Soft interrupt register";
        field {
            name = "software_int_vector";
            desc = "Software interrupt vector.";
            sw = r;
        } software_int_vector[31:0];
    } SOLFTYPE @ 0x0020;
`endif

`ifdef SYS_CTRL_PEREN_REG
    reg {
        name = "Peripheral Clock Enable Register";
        desc = "Soft interrupt register";
        field {
            desc = "TODO";
        } todo = 0;
    } PEREN @ 0x0024;
`endif

`ifdef SYS_CTRL_PERDIS_REG
    reg {
        name = "Peripheral Clock Disable Register";
        desc = "Soft interrupt register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERDIS @ 0x0028;
`endif

`ifdef SYS_CTRL_PERCLKEN_REG
    reg {
        name = "Peripheral Clock Status Register";
        desc = "Soft interrupt register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERCLKEN @ 0x002C;
`endif

`ifdef SYS_CTRL_PERISTAT_REG
    reg {
        name = "Peripheral Status Register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERISTAT @ 0x0030;
`endif

`ifdef SYS_CTRL_PERIPHCTRL2_REG
    reg {
        name = "Peripheral control register 2";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL2 @ 0x0034;
`endif

`ifdef SYS_CTRL_PERIPHCTRL3_REG
    reg {
        name = "Peripheral control register 3";
        desc = "SATA PHY control register device";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL3 @ 0x0038;
`endif

`ifdef SYS_CTRL_PERIPHCTRL4_REG
    reg {
        name = "Peripheral control register 4";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL4 @ 0x003C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL5_REG
    reg {
        name = "Peripheral control register 5";
        desc = "MEDIA0 bus master port timeout control register 0";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL5 @ 0x0040;
`endif

    reg {
        name = "Lock register of the critical system control register";
        field {
            desc = "TODO";
        } todo = 0;
    } LOCK @ 0x0044;

`ifdef SYS_CTRL_PERIPHCTRL6_REG
    reg {
        name = "Peripheral control register 6";
        desc = "MEDIA0 bus master port timeout control register 1";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL6 @ 0x0048;
`endif

`ifdef SYS_CTRL_PERIPHCTRL7_REG
    reg {
        name = "Peripheral control register 7";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL7 @ 0x004C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL8_REG
    reg {
        name = "Peripheral control register 8";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL8 @ 0x0050;
`endif

`ifdef SYS_CTRL_PERIPHCTRL9_REG
    reg {
        name = "Peripheral control register 9";
        desc = "MEDIA0 bus master port priority control register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL9 @ 0x0054;
`endif

`ifdef SYS_CTRL_PERIPHCTRL10_REG
    reg {
        name = "Peripheral control register 10";
        desc = "System bus master port timeout control register 0";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL10 @ 0x0058;
`endif

`ifdef SYS_CTRL_PERIPHCTRL11_REG
    reg {
        name = "Peripheral control register 11";
        desc = "System bus master port timeout control register 1";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL11 @ 0x005C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL12_REG
    reg {
        name = "Peripheral control register 12";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL12 @ 0x0060;
`endif

`ifdef SYS_CTRL_PERIPHCTRL13_REG
    reg {
        name = "Peripheral control register 13";
        desc = "System bus master port timeout control register 1";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL13 @ 0x0064;
`endif

`ifdef SYS_CTRL_PERIPHCTRL14_REG
    reg {
        name = "Peripheral control register 14";
        desc = "System bus slave end port priority control register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL14 @ 0x0068;
`endif

`ifdef SYS_CTRL_PERIPHCTRL15_REG
    reg {
        name = "Peripheral control register 15";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL15 @ 0x006C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL16_REG
    reg {
        name = "Peripheral control register 16";
        desc = "MEDIA1 bus master port timeout control register 0";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL16 @ 0x0070;
`endif

`ifdef SYS_CTRL_PERIPHCTRL17_REG
    reg {
        name = "Peripheral control register 17";
        desc = "MEDIA1 bus master port timeout control register 1";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL17 @ 0x0074;
`endif

`ifdef SYS_CTRL_PERIPHCTRL18_REG
    reg {
        name = "Peripheral control register 18";
        desc = "MEDIA1 bus master port timeout control register 2";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL18 @ 0x0078;
`endif

`ifdef SYS_CTRL_PERIPHCTRL19_REG
    reg {
        name = "Peripheral control register 19";
        desc = "MEDIA1 bus master port priority control register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL19 @ 0x007C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL20_REG
    reg {
        name = "Peripheral control register 20";
        desc = "USB control register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL20 @ 0x0080;
`endif

`ifdef SYS_CTRL_PERIPHCTRL21_REG
    reg {
        name = "Peripheral control register 21";
        desc = "USB PHY control register 0";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL21 @ 0x0084;
`endif

`ifdef SYS_CTRL_PERIPHCTRL22_REG
    reg {
        name = "Peripheral control register 22";
        desc = "USB PHY control register 1";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL22 @ 0x0088;
`endif

`ifdef SYS_CTRL_SYSSTAT_REG
    reg {
        name = "System status register";
        desc = "PLL_LOCK";
        field {
            desc = "TODO";
        } todo = 0;
    } SYSSTAT @ 0x008C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL23_0x8C_REG
    reg {
        name = "Peripheral control register 23";
        desc = "MDDRC out-of-order configuration outtodr_ctrl register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL23 @ 0x008C;
`endif

`ifdef SYS_CTRL_PERIPHCTRL23_0x90_REG
    reg {
        name = "Peripheral control register 23";
        desc = "MDDRC out-of-order configuration outtodr_ctrl register";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL23 @ 0x0090;
`endif

`ifdef SYS_CTRL_DDRT0_0x90_REG
    reg {
        name = "DDR Training Register 0";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt0";
            desc = "DDR training register 0";
        } ddrt0[31:0];
    } DDRT0 @ 0x0090;
`endif

`ifdef SYS_CTRL_PERIPHCTRL24_REG
    reg {
        name = "Peripheral control register 24";
        desc = "The peripheral control register 24 (FE PHY address configuration register).";

        enum PERIPHCTRL24_fephy_led_ctrl_enum {
            NOT_REVERSED = 0x0 { desc = "Polarity is not reversed."; };
            REVERSED     = 0x1 { desc = "Polarity is reversed."; };
        };

        field {
            name = "fephy_led_ctrl";
            desc = "FE PHY led light polarity control.";
            encode = PERIPHCTRL24_fephy_led_ctrl_enum;
        } fephy_led_ctrl[12:12];

        enum PERIPHCTRL24_fephy_sel_enum {
            NOT_REVERSED = 0x0 { desc = "Select the internally integrated FE PHY."; };
            REVERSED     = 0x1 { desc = "Select external FE PHY."; };
        };

        field {
            name = "fephy_sel";
            desc = "FE PHY selection.";
            encode = PERIPHCTRL24_fephy_sel_enum;
        } fephy_sel[8:8];

        field {
            name = "fephy_ad";
            desc = "PHY address of internally integrated FE PHY.";
        } fephy_ad[4:0];

    } PERIPHCTRL24 @ 0x0094;
`endif

`ifdef SYS_CTRL_DDRT1_0x94_REG
    reg {
        name = "DDR Training Register 1";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt1";
            desc = "DDR training register 1";
        } ddrt1[31:0];
    } DDRT1 @ 0x0094;
`endif

`ifdef SYS_CTRL_PERIPHCTRL25_REG
    reg {
        name = "Peripheral control register 25";
        desc = "The Peripheral Control Register 25 (SATA PHY Control Register 1).";

        field {
            name = "sata_test_byp_mode";
            desc = "All the input interfaces of SATA in the enable ASIC are connected to the output terminals through pure combinational logic to improve the interface test coverage.";
            encode = SYSCTL_one_enable_enum;
        } sata_test_byp_mode[21:21];

        field {
            name = "sata_test_burnin_mode";
            desc = "
                SATA burn-in test mode is enabled.

                Note: Enable as many internal logic flips as possible, use with [sata_test_byp_mode] signal during burn-in test.
            ";
            encode = SYSCTL_one_enable_enum;
        } sata_test_burnin_mode[20:20];

        enum PERIPHCTRL25_sata_test_pddq_enum {
            NO_POWER_OFF = 0x0 { desc = "No Power Off"; };
            POWER_OFF    = 0x1 { desc = "Power Off"; };
        };

        field {
            name = "sata_test_pddq";
            desc = "SATA PHY power on and off control.";
            encode = PERIPHCTRL25_sata_test_pddq_enum;
        } sata_test_pddq[2:2];

    } PERIPHCTRL25 @ 0x0098;
`endif

`ifdef SYS_CTRL_DDRT2_0x98_REG
    reg {
        name = "DDR Training Register 2";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt2";
            desc = "DDR training register 2";
        } ddrt2[31:0];
    } DDRT2 @ 0x0098;
`endif

`ifdef SYS_CTRL_DDRT3_0x9C_REG
    reg {
        name = "DDR Training Register 3";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt3";
            desc = "DDR training register 3";
        } ddrt3[31:0];
    } DDRT3 @ 0x009C;
`endif

`ifdef SYS_CTRL_DDRT4_0xA0_REG
    reg {
        name = "DDR Training Register 4";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt4";
            desc = "DDR training register 4";
        } ddrt4[31:0];
    } DDRT4 @ 0x00A0;
`endif

`ifdef SYS_CTRL_PERIPHCTRL28_REG
    reg {
        name = "Peripheral control register 28";
        desc = "Peripheral control register 28 (IO control register 0).";

        enum PERIPHCTRL28_spi_sclk_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "spi_sclk_ioctrl_ds";
            desc = "spi_sclk Output drive capability selection.";
            encode = PERIPHCTRL28_spi_sclk_ioctrl_ds_enum;
        } spi_sclk_ioctrl_ds[30:28];

        enum PERIPHCTRL28_aio_ws_tx_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "aio_ws_tx_ioctrl_ds";
            desc = "aio_ws_tx output drive capability selection.";
            encode = PERIPHCTRL28_aio_ws_tx_ioctrl_ds_enum;
        } aio_ws_tx_ioctrl_ds[26:24];

        enum PERIPHCTRL28_aio_bclk_tx_ioctrl_ds_enum {
            mA0     = 0x0 { desc = "0mA (High Z)"; };
            mA3     = 0x1 { desc = "3mA (Active)"; };
            mA4_0   = 0x2 { desc = "4mA (Active)"; };
            mA7_0   = 0x3 { desc = "7mA"; };
            mA4_1   = 0x4 { desc = "4mA"; };
            mA7_1   = 0x5 { desc = "7mA"; };
            mA8     = 0x6 { desc = "8mA (Active)"; };
            mA11    = 0x7 { desc = "11mA"; };
        };

        field {
            name = "aio_bclk_tx_ioctrl_ds";
            desc = "aio_bclk_tx output drive capability selection (@SS,125℃ 2.97V/1.08V Io1 at 0.4V).";
            encode = PERIPHCTRL28_aio_bclk_tx_ioctrl_ds_enum;
        } aio_bclk_tx_ioctrl_ds[22:20];

        enum PERIPHCTRL28_aio_ws_rx_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "aio_ws_rx_ioctrl_ds";
            desc = "aio_ws_rx_ioctrl_ds Output drive capability selection.";
            encode = PERIPHCTRL28_aio_ws_rx_ioctrl_ds_enum;
        } aio_ws_rx_ioctrl_ds[18:16];

        enum PERIPHCTRL28_aio_bclk_rx_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "aio_bclk_rx_ioctrl_ds";
            desc = "aio_bclk_rx Output drive capability selection.";
            encode = PERIPHCTRL28_aio_bclk_rx_ioctrl_ds_enum;
        } aio_bclk_rx_ioctrl_ds[14:12];

        enum PERIPHCTRL28_aio_mclk_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "aio_mclk_ioctrl_ds";
            desc = "aio_mclk Output drive capability selection.";
            encode = PERIPHCTRL28_aio_mclk_ioctrl_ds_enum;
        } aio_mclk_ioctrl_ds[10:8];

        enum PERIPHCTRL28_vga_hs_vs_ioctrl_ds_enum {
            mA0     = 0x0 { desc = "0mA (High Z)"; };
            mA4     = 0x1 { desc = "4mA"; };
            mA8     = 0x2 { desc = "8mA"; };
            mA12_0  = 0x3 { desc = "12mA"; };
            mA12_1  = 0x4 { desc = "12mA"; };
            mA16    = 0x5 { desc = "16mA"; };
            mA20    = 0x6 { desc = "20mA"; };
            mA24    = 0x7 { desc = "24mA"; };
        };

        field {
            name = "vga_hs_vs_ioctrl_ds";
            desc = "aio_mclk Output drive capability selection.";
            encode = PERIPHCTRL28_vga_hs_vs_ioctrl_ds_enum;
        } vga_hs_vs_ioctrl_ds[6:4];

        enum PERIPHCTRL28_vi_adc_clk_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "aio_mclk_ioctrl_ds";
            desc = "vi_adc_clk Output drive capability selection.";
            encode = PERIPHCTRL28_vi_adc_clk_ioctrl_ds_enum;
        } vi_adc_clk_ioctrl_ds[2:0];

    } PERIPHCTRL28 @ 0x00A4;
`endif

`ifdef SYS_CTRL_DDRT5_0xA4_REG
    reg {
        name = "DDR Training Register 5";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt5";
            desc = "DDR training register 5";
        } ddrt5[31:0];
    } DDRT5 @ 0x00A4;
`endif

`ifdef SYS_CTRL_PERIPHCTRL29_REG
    reg {
        name = "Peripheral control register 29";
        desc = "Peripheral control register 29 (IO control register 1).";

        enum PERIPHCTRL29_sfc_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "sfc_ioctrl_ds";
            desc = "SFC data pad output drive capability.";
            encode = PERIPHCTRL29_sfc_ioctrl_ds_enum;
        } sfc_ioctrl_ds[6:4];

        enum PERIPHCTRL29_spi_sdo_ioctrl_ds_enum {
            mA0         = 0x0 { desc = "0mA (High Z)"; };
            mA3         = 0x1 { desc = "3mA"; };
            mA4         = 0x2 { desc = "4mA"; };
            // RESERVED   = 0x3 { desc = "RESERVED"; };
            // RESERVED   = 0x4 { desc = "RESERVED"; };
            // RESERVED   = 0x5 { desc = "RESERVED"; };
            mA8         = 0x6 { desc = "8mA"; };
            mA11        = 0x7 { desc = "11mA"; };
        };

        field {
            name = "spi_sdo_ioctrl_ds";
            desc = "spi_sdo output drive capability.";
            encode = PERIPHCTRL29_spi_sdo_ioctrl_ds_enum;
        } spi_sdo_ioctrl_ds[2:0];

    } PERIPHCTRL29 @ 0x00A8;
`endif

`ifdef SYS_CTRL_DDRT6_0xA8_REG
    reg {
        name = "DDR Training Register 6";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt6";
            desc = "DDR training register 6";
        } ddrt6[31:0];
    } DDRT6 @ 0x00A8;
`endif

`ifdef SYS_CTRL_PERIPHCTRL30_0xAC_REG
    reg {
        name = "Peripheral control register 30";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL30 @ 0x00AC;
`endif

`ifdef SYS_CTRL_DDRT7_0xAC_REG
    reg {
        name = "DDR Training Register 7";
        desc = "
        !!! CAUTION
            This register is not reset when the system is soft-reset
        ";
        field {
            name = "ddrt7";
            desc = "DDR training register 7";
        } ddrt7[31:0];
    } DDRT7 @ 0x00AC;
`endif

`ifdef SYS_CTRL_PERIPHCTRL31_0xB0_REG
    reg {
        name = "Peripheral control register 31";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL31 @ 0x00B0;
`endif

`ifdef SYS_CTRL_PERIPHCTRL32_0xB4_REG
    reg {
        name = "Peripheral control register 32";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL32 @ 0x00B4;
`endif

`ifdef SYS_CTRL_PERIPHCTRL33_0xB8_REG
    reg {
        name = "Peripheral control register 33";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL33 @ 0x00B8;
`endif

`ifdef SYS_CTRL_PERIPHCTRL34_0xBC_REG
    reg {
        name = "Peripheral control register 34";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL34 @ 0x00BC;
`endif

`ifdef SYS_CTRL_PERIPHCTRL35_0xC0_REG
    reg {
        name = "Peripheral control register 35";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL35 @ 0x00C0;
`endif

`ifdef SYS_CTRL_PERIPHCTRL36_0xC4_REG
    reg {
        name = "Peripheral control register 36";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL36 @ 0x00C4;
`endif

`ifdef SYS_CTRL_PERIPHCTRL37_0xC8_REG
    reg {
        name = "Peripheral control register 37";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL37 @ 0x00C8;
`endif

`ifdef SYS_CTRL_PERIPHCTRL38_0xCC_REG
    reg {
        name = "Peripheral control register 38";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL38 @ 0x00CC;
`endif

`ifdef SYS_CTRL_PERIPHCTRL39_0xD0_REG
    reg {
        name = "Peripheral control register 39";
        field {
            desc = "TODO";
        } todo = 0;
    } PERIPHCTRL39 @ 0x00D0;
`endif

`ifdef SYS_CTRL_SYSBOOT0_REG
    reg {
        name = "System Boot Register 0";
        field {
            name = "sysboot0";
            desc = "System boot register 0";
        } sysboot0[31:0];
    } SYSBOOT0 @ 0x0130;
`endif

`ifdef SYS_CTRL_SYSBOOT1_REG
    reg {
        name = "System Boot Register 1";
        field {
            name = "sysboot1";
            desc = "System boot register 1";
        } sysboot1[31:0];
    } SYSBOOT1 @ 0x0134;
`endif

`ifdef SYS_CTRL_SYSBOOT2_REG
    reg {
        name = "System Boot Register 2";
        field {
            name = "sysboot2";
            desc = "System boot register 2";
        } sysboot2[31:0];
    } SYSBOOT2 @ 0x0138;
`endif

`ifdef SYS_CTRL_SYSBOOT3_REG
    reg {
        name = "System Boot Register 3";
        field {
            name = "sysboot3";
            desc = "System boot register 3";
        } sysboot3[31:0];
    } SYSBOOT3 @ 0x013C;
`endif

`ifdef SYS_CTRL_SYSBOOT4_REG
    reg {
        name = "System Boot Register 4";
        field {
            name = "sysboot4";
            desc = "System boot register 4";
        } sysboot4[31:0];
    } SYSBOOT4 @ 0x0140;
`endif

`ifdef SYS_CTRL_SYSBOOT5_REG
    reg {
        name = "System Boot Register 5";
        field {
            name = "sysboot5";
            desc = "System boot register 5";
        } sysboot5[31:0];
    } SYSBOOT5 @ 0x0144;
`endif

`ifdef SYS_CTRL_SYSBOOT6_REG
    reg {
        name = "System Boot Register 6";
        field {
            name = "sysboot6";
            desc = "System boot register 6";
        } sysboot6[31:0];
    } SYSBOOT6 @ 0x0148;
`endif

`ifdef SYS_CTRL_SYSBOOT7_REG
    reg {
        name = "System Boot Register 7";
        field {
            name = "sysboot7";
            desc = "System boot register 7";
        } sysboot7[31:0];
    } SYSBOOT7 @ 0x014C;
`endif

`ifdef SYS_CTRL_SYSBOOT8_REG
    reg {
        name = "System Boot Register 8";
        field {
            name = "sysboot8";
            desc = "System boot register 8";
        } sysboot8[31:0];
    } SYSBOOT8 @ 0x0150;
`endif

`ifdef SYS_CTRL_SYSBOOT9_REG
    reg {
        name = "System Boot Register 9";
        field {
            name = "sysboot9";
            desc = "System boot register 9";
        } sysboot9[31:0];
    } SYSBOOT9 @ 0x0154;
`endif

`ifdef SYS_CTRL_SYSBOOT10_REG
    reg {
        name = "System Boot Register 10";
        field {
            name = "sysboot10";
            desc = "System boot register 10";
        } sysboot10[31:0];
    } SYSBOOT10 @ 0x0158;
`endif

`ifdef SYS_CTRL_SYSBOOT11_REG
    reg {
        name = "System Boot Register 11";
        field {
            name = "sysboot11";
            desc = "System boot register 11";
        } sysboot11[31:0];
    } SYSBOOT11 @ 0x015C;
`endif

`ifdef SYS_CTRL_DIE_ID0_REG
    reg {
        name = "Die ID 0 register";

        field {
            name = "die_id0";
            sw = r;
        } die_id0[31:0];

    } DIE_ID0 @ 0x0400;
`endif

`ifdef SYS_CTRL_DIE_ID1_REG
    reg {
        name = "Die ID 1 register";

        field {
            name = "die_id1";
            sw = r;
        } die_id1[31:0];

    } DIE_ID1 @ 0x0404;
`endif

`ifdef SYS_CTRL_DIE_ID2_REG
    reg {
        name = "Die ID 2 register";

        field {
            name = "die_id2";
            sw = r;
        } die_id2[31:0];

    } DIE_ID2 @ 0x0408;
`endif

`ifdef SYS_CTRL_DIE_ID3_REG
    reg {
        name = "Die ID 3 register";

        field {
            name = "die_id3";
            sw = r;
        } die_id3[31:0];

    } DIE_ID3 @ 0x040C;
`endif

`ifdef SYS_CTRL_DIE_ID4_REG
    reg {
        name = "Die ID 4 register";

        field {
            name = "die_id4";
            sw = r;
        } die_id4[31:0];

    } DIE_ID4 @ 0x0410;
`endif

`ifdef SYS_CTRL_DIE_ID5_REG
    reg {
        name = "Die ID 5 register";

        field {
            name = "die_id5";
            sw = r;
        } die_id5[31:0];

    } DIE_ID5 @ 0x0414;
`endif

`ifdef SYS_CTRL_SYSID_REG
    reg {
        name = "Chip ID register";
        desc = "Chip ID Register";

        enum SYSID_enum {
            HI3516AV200 = 0x06000001 { desc = "Hi3516A V200"; };
            HI3516AV300 = 0x3516A300 { desc = "Hi3516A V300"; };
            // TODO: Add other SYSID values as I run across them
        };

        field {
            name = "sysid";
            encode = SYSID_enum;
            sw = r;
        } sysid[31:0];

    } SCSYSID @ 0x0EE0;
`endif

`ifdef SYS_CTRL_SYSID0_REG
    reg {
        name = "Chip ID register 0";
        desc = "
        The last two characters of the chip version number

        ![SYS_ID](assets/sys-ctrl-system-id.png)
        ";

        enum SYSID0_enum {
            HIXXXX_VX00     = 0x0 { desc = "Version ending in `00`"; };
            // TODO: Add other SYSID values as I run across them
        };

        field {
            name = "sysid0";
            desc = "`HI3520D V2XX`, where `XX` is this field";
            encode = SYSID0_enum;
            sw = r;
        } sysid0[7:0] = 0x00;

    } SCSYSID0 @ 0x0EE0;
`endif

`ifdef SYS_CTRL_SYSID1_REG
    reg {
        name = "Chip ID register 1";
        desc = "The last character of the chip model, and first character of the version number";

        enum SYSID1_enum {
            HIXXXX_V1XX     = 0x1 { desc = "Chip `HIXXXX V1XX`"; };
            HIXXXXC_V3XX     = 0xC3 { desc = "Chip `HIXXXXC V3XX`"; };
            // TODO: Add other SYSID values as I run across them
        };

        field {
            name = "sysid1";
            desc = "`HI3520X VX00`, where `X VX` is this field.";
            encode = SYSID1_enum;
            sw = r;
        } sysid1[7:0] = 0xD1;

    } SCSYSID1 @ 0x0EE4;
`endif

`ifdef SYS_CTRL_SYSID2_REG
    reg {
        name = "Chip ID register 2";
        desc = "The third and fourth characters of the chip model.";

        enum SYSID2_enum {
            HIXX11 = 0x11 { desc = "Chip `HIXX11`"; };
            HIXX15 = 0x15 { desc = "Chip `HIXX15`"; };
            HIXX16 = 0x16 { desc = "Chip `HIXX16`"; };
            HIXX18 = 0x18 { desc = "Chip `HIXX18`"; };
            HIXX19 = 0x19 { desc = "Chip `HIXX19`"; };
            HIXX20 = 0x20 { desc = "Chip `HIXX20`"; };
            HIXX31 = 0x31 { desc = "Chip `HIXX31`"; };
            HIXX35 = 0x35 { desc = "Chip `HIXX35`"; };
            // TODO: Add other SYSID values as I run across them
        };

        field {
            name = "sysid2";
            desc = "`HI35XXD V200`, where `XX` is this field";
            encode = SYSID2_enum;
            sw = r;
        } sysid2[7:0] = 0x20;

    } SCSYSID2 @ 0x0EE8;
`endif

`ifdef SYS_CTRL_SYSID3_REG
    reg {
        name = "Chip ID register 3";
        desc = "The first and second characters of the chip model.";

        enum SYSID3_enum {
            HI35XX = 0x35 { desc = "Chip `HI35XX`"; };
            // TODO: Add other SYSID values as I run across them
        };

        field {
            name = "sysid3";
            desc = "`HIXX20D V200`, where `XX` is this field";
            encode = SYSID3_enum;
            sw = r;
        } sysid3[7:0] = 0x35;

    } SCSYSID3 @ 0x0EEC;
`endif

};
`endif
